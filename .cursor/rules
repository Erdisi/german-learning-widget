# German Learning Widget - Development Rules & Context
# This file provides comprehensive guidelines for AI assistants working on this project

## Project Overview
project_name: "German Learning Widget"
project_type: "Android Native Application"
primary_language: "Kotlin"
target_platform: "Android (API 24+)"
architecture: "MVVM with Repository Pattern"

description: |
  A native Android application that facilitates German language learning through innovative 
  widget-based delivery. The app provides contextual German sentences directly on users' 
  home screens, enabling passive learning throughout daily device usage. Features multiple 
  widget types including standard bookmarks, Hero-style carousel widgets, and main learning widgets.

## Tech Stack & Dependencies
ui_framework: "Jetpack Compose"
build_system: "Gradle with Kotlin DSL"
architecture_components:
  - "androidx.lifecycle.viewmodel-compose"
  - "androidx.navigation.compose"
  - "androidx.datastore.preferences"
  - "androidx.work.runtime-ktx"
widget_framework: "androidx.glance.appwidget"
design_system: "Material Design 3"

core_dependencies:
  - "androidx.compose.ui"
  - "androidx.compose.material3"
  - "androidx.activity.compose"
  - "kotlinx.coroutines"

## Docker Infrastructure & Usage Guidelines

### Docker Implementation Status
docker_implementation_status: "PRODUCTION_READY"
docker_completion_percentage: "90%"
docker_infrastructure_files:
  - "Dockerfile (multi-stage with 5 environments)"
  - "docker-compose.yml (5 services)"
  - ".github/workflows/docker-ci.yml (CI/CD pipeline)"
  - "docker-dev.sh (interactive development script)"
  - "docker-gradle.properties (container-specific config)"
  - ".dockerignore (build context optimization)"
  - "DOCKER_GUIDE.md (comprehensive usage guide)"
  - "DOCKER_INSTALLATION_GUIDE.md (macOS setup)"

### When to Use Docker

#### ✅ ALWAYS Use Docker For:
1. **CI/CD Pipelines**
   - GitHub Actions builds (automatic)
   - Automated testing and linting
   - Release APK/AAB generation
   - Play Store deployment automation

2. **Team Collaboration**
   - New team member onboarding
   - Linux developer environments
   - Build environment consistency
   - Ensuring identical build results

3. **Production Deployments**
   - Release builds for distribution
   - Automated quality assurance
   - Build artifact generation
   - Security scanning and validation

4. **Testing & Validation**
   - Integration testing
   - Cross-platform build verification
   - Performance benchmarking
   - Dependency validation

#### ⚠️ CONDITIONAL Use For:
1. **Local Development on x86_64 Systems**
   - Intel-based Mac development
   - Linux development environments
   - Windows with WSL2

2. **Debugging & Troubleshooting**
   - When host system has issues
   - For build environment isolation
   - When dependencies conflict

#### ❌ AVOID Docker For:
1. **Apple Silicon (ARM64) Local Development**
   - M1/M2/M3 Mac development
   - Known AAPT2 architectural incompatibility
   - Use host system builds instead

### Apple Silicon Limitation
apple_silicon_status: "INCOMPATIBLE"
apple_silicon_issue: |
  AAPT2 (Android Asset Packaging Tool 2) has architectural incompatibility when running 
  Linux Docker containers on Apple Silicon Macs. This causes build failures during 
  APK compilation phase.

apple_silicon_workaround: |
  - Use host system builds on Apple Silicon Macs
  - Host builds work perfectly (19 seconds for clean assembleDebug)
  - CI/CD pipeline works on x86_64 GitHub Actions runners
  - Team collaboration works for Intel/Linux developers

### Docker Commands Reference

#### Quick Development Commands
```bash
# Start development environment
./docker-dev.sh dev

# Build debug APK
./docker-dev.sh build-debug

# Run tests
./docker-dev.sh test

# Clean and rebuild
./docker-dev.sh rebuild

# Check status
./docker-dev.sh status

# Get help
./docker-dev.sh help
```

#### Direct Docker Compose Commands
```bash
# Build development environment
docker-compose build dev

# Run debug build
docker-compose run --rm ci-build ./gradlew assembleDebug

# Run tests with reports
docker-compose run --rm test ./gradlew test lint

# Production build (requires signing setup)
docker-compose run --rm production-build
```

### Development Environment Decision Matrix

| Developer Platform | Recommended Approach | Reason |
|-------------------|---------------------|---------|
| Apple Silicon Mac | Host System Build | AAPT2 incompatibility |
| Intel Mac | Docker or Host | Both work well |
| Linux (x86_64) | Docker Preferred | Consistent environment |
| Windows WSL2 | Docker Preferred | Better Android SDK support |
| CI/CD Servers | Docker Always | Consistency and automation |

### Docker Project Structure
```
docker/
├── Dockerfile (multi-stage: android-base → development → ci-build → production → runtime)
├── docker-compose.yml (services: dev, ci-build, production, test, gradle-cache)
├── docker-dev.sh (interactive helper script)
├── docker-gradle.properties (container-specific Gradle config)
└── .dockerignore (build context optimization)
```

### Environment Variables for Docker
```bash
# Gradle optimization for containers
GRADLE_OPTS="-Dorg.gradle.daemon=false -Dorg.gradle.parallel=false -Dorg.gradle.workers.max=2"

# Android SDK configuration
ANDROID_SDK_ROOT="/opt/android-sdk"
ANDROID_HOME="/opt/android-sdk"
ANDROID_BUILD_TOOLS_VERSION="35.0.0"

# Release signing (when needed)
KEYSTORE_PASSWORD="your_keystore_password"
KEY_ALIAS="upload"
KEY_PASSWORD="your_key_password"
```

### AI Assistant Docker Guidelines

#### When Suggesting Docker Usage:
1. **Always check developer platform first**
   - Ask about Mac type (Intel vs Apple Silicon)
   - Recommend host builds for Apple Silicon
   - Suggest Docker for other platforms

2. **For CI/CD Changes**
   - Always use Docker approach
   - Reference `.github/workflows/docker-ci.yml`
   - Ensure compatibility with existing pipeline

3. **For Team Development**
   - Recommend Docker for consistency
   - Guide to `docker-dev.sh` usage
   - Reference `DOCKER_INSTALLATION_GUIDE.md`

#### Docker Troubleshooting Steps:
1. Check platform compatibility (Apple Silicon warning)
2. Verify Docker Desktop is running
3. Check available disk space (>10GB recommended)
4. Clear Docker cache if needed (`docker system prune`)
5. Rebuild images if persistent issues (`./docker-dev.sh rebuild`)

#### Common Docker Issues & Solutions:
```bash
# Out of disk space
docker system prune -af && docker volume prune -f

# Rebuild from scratch
docker-compose build --no-cache

# Permission issues (Linux/macOS)
sudo chown -R $USER:$USER .

# Memory issues
# Increase Docker Desktop memory limit to 8GB
```

## Project Structure & Architecture

### Directory Structure
```
app/src/main/
├── java/com/germanleraningwidget/
│   ├── data/
│   │   ├── model/           # Data models (GermanSentence, UserPreferences)
│   │   └── repository/      # Repository implementations
│   ├── ui/
│   │   ├── components/      # Reusable UI components
│   │   ├── screen/          # Screen composables
│   │   ├── theme/           # Material Design theme
│   │   └── viewmodel/       # ViewModels for state management
│   ├── widget/              # Widget providers and implementations
│   ├── worker/              # Background processing (WorkManager)
│   ├── GermanLearningApplication.kt
│   └── MainActivity.kt
├── res/
│   ├── drawable/           # Vector drawables and backgrounds
│   ├── layout/             # Widget XML layouts
│   ├── values/             # Strings, colors, themes
│   └── xml/                # Widget configurations
└── AndroidManifest.xml
```

### Architecture Layers
1. **UI Layer**: Jetpack Compose screens and components
2. **Domain Layer**: Business logic and use cases
3. **Data Layer**: Repositories and data sources
4. **Widget Layer**: Home screen widgets (RemoteViews)
5. **Background Layer**: WorkManager for scheduled tasks

## Component-Specific Rules

### Widget Development Rules
template_reference: "BookmarksWidget.kt and GermanLearningWidget.kt"

widget_creation_steps:
  1. "Create widget provider class extending AppWidgetProvider"
  2. "Create XML layout in res/layout/ (ensure RemoteViews compatibility)"
  3. "Create widget info XML in res/xml/"
  4. "Register widget in AndroidManifest.xml"
  5. "Add drawable resources for backgrounds and buttons"
  6. "Update repository to notify widget of data changes"

widget_naming_convention:
  - "Class: [Purpose]Widget.kt (e.g., BookmarksHeroWidget.kt)"
  - "Layout: widget_[purpose].xml (e.g., widget_bookmarks_hero.xml)"
  - "Info: [purpose]_widget_info.xml (e.g., bookmarks_hero_widget_info.xml)"
  - "Preview: widget_[purpose]_preview.xml"

widget_remoteviews_constraints:
  forbidden_attributes:
    - "android:alpha (use color transparency instead)"
    - "android:paddingHorizontal/Vertical (use individual padding)"
    - "android:layout_marginVertical (use top/bottom margins)"
    - "android:lineSpacingExtra (not supported)"
  allowed_views:
    - "LinearLayout, RelativeLayout, FrameLayout"
    - "TextView, ImageView, ImageButton"
    - "ProgressBar (limited styles)"
  forbidden_views:
    - "View (for decorative purposes)"
    - "Complex nested structures"
    - "Custom views"

widget_best_practices:
  - "Always test with lint for RemoteViews compatibility"
  - "Use companion object for updateAllWidgets() method"
  - "Implement proper error handling and empty states"
  - "Use PendingIntent.FLAG_IMMUTABLE for Android 12+"
  - "Cache widget data to avoid repeated repository calls"

### Data Model Rules
template_reference: "GermanSentence.kt and UserPreferences.kt"

data_model_patterns:
  - "Use data classes for immutable models"
  - "Implement validation methods with Result<T> pattern"
  - "Add companion objects for constants and factory methods"
  - "Use sealed classes for states and results"
  - "Implement proper equals/hashCode for caching"

naming_conventions:
  - "Data classes: PascalCase (e.g., GermanSentence)"
  - "Properties: camelCase (e.g., germanText)"
  - "Enums: SCREAMING_SNAKE_CASE (e.g., DIFFICULTY_LEVEL)"
  - "Constants: UPPER_SNAKE_CASE in companion objects"

validation_patterns:
  - "Use sealed class ValidationResult for validation responses"
  - "Implement extension functions for validation logic"
  - "Return Result<T> for operations that can fail"
  - "Use nullable types sparingly, prefer default values"

### Repository Rules
template_reference: "SentenceRepository.kt"

repository_patterns:
  - "Use singleton pattern with getInstance() method"
  - "Implement StateFlow for reactive data"
  - "Use mutex for thread-safe operations"
  - "Cache frequently accessed data"
  - "Provide both synchronous and Flow-based APIs"

repository_structure:
  required_methods:
    - "getInstance(context: Context): RepositoryName"
    - "initialize() for setup"
    - "clearCache() for memory management"
    - "getStatistics() for monitoring"

error_handling:
  - "Use try-catch blocks with proper logging"
  - "Return Result<T> for operations that can fail"
  - "Implement fallback mechanisms for critical operations"
  - "Log errors with appropriate detail level"

widget_integration:
  - "Use reflection to notify widgets (avoid circular dependencies)"
  - "Implement notifyWidgets() method for data changes"
  - "Handle ClassNotFoundException gracefully"

### Screen Development Rules
template_reference: "HomeScreen.kt and OnboardingScreen.kt"

screen_structure:
  - "Create composable function with Screen suffix"
  - "Use ViewModel for state management"
  - "Implement proper navigation handling"
  - "Follow Material Design 3 guidelines"

composable_patterns:
  - "Use @Composable annotation"
  - "Pass ViewModel as parameter, not create inside"
  - "Use collectAsState() for StateFlow observation"
  - "Implement proper remember and rememberSaveable usage"

navigation_rules:
  - "Define navigation routes as constants"
  - "Use type-safe navigation arguments"
  - "Handle back navigation properly"
  - "Implement deep linking where appropriate"

### ViewModel Rules
template_reference: "OnboardingViewModel.kt"

viewmodel_patterns:
  - "Extend ViewModel class"
  - "Use StateFlow for UI state"
  - "Implement proper coroutine scoping"
  - "Use mutex for thread-safe state updates"

state_management:
  - "Create sealed class for UI states"
  - "Use data classes for complex state"
  - "Implement distinctUntilChanged for performance"
  - "Handle loading, success, and error states"

## Code Style & Conventions

### Kotlin Style Guide
- "Use 4 spaces for indentation"
- "Line length: 120 characters maximum"
- "Use trailing commas in multi-line constructs"
- "Prefer expression functions for single expressions"
- "NEVER use emoji icons in UI text - use Material Design icons instead for consistency and professionalism"

### Import Organization
```kotlin
// Android/Kotlin standard library
import android.content.Context
import kotlinx.coroutines.flow.StateFlow

// AndroidX libraries
import androidx.compose.runtime.Composable
import androidx.lifecycle.ViewModel

// Project imports
import com.germanleraningwidget.data.model.GermanSentence
```

### Naming Conventions
files:
  - "Activities: [Name]Activity.kt"
  - "Fragments: [Name]Fragment.kt"
  - "Composables: [Name]Screen.kt or [Name]Component.kt"
  - "ViewModels: [Name]ViewModel.kt"
  - "Repositories: [Name]Repository.kt"
  - "Workers: [Name]Worker.kt"

classes_and_functions:
  - "Classes: PascalCase"
  - "Functions: camelCase"
  - "Constants: UPPER_SNAKE_CASE"
  - "Private members: prefix with underscore for StateFlow backing properties"

### Documentation Standards
- "Use KDoc for public APIs"
- "Include @param and @return tags"
- "Add usage examples for complex functions"
- "Document thread safety guarantees"

## Testing Guidelines

### Unit Testing
- "Test ViewModels with coroutine testing"
- "Mock repositories and external dependencies"
- "Test error conditions and edge cases"
- "Use descriptive test method names"

### Widget Testing
- "Test widget updates and data synchronization"
- "Verify RemoteViews compatibility"
- "Test different screen sizes and orientations"
- "Validate widget performance and memory usage"

## Performance Guidelines

### Memory Management
- "Use lazy initialization where appropriate"
- "Clear caches when memory pressure is high"
- "Avoid memory leaks in ViewModels and repositories"
- "Use weak references for listeners"

### Widget Performance
- "Minimize widget update frequency"
- "Cache widget data to reduce repository calls"
- "Use efficient layouts (avoid deep nesting)"
- "Optimize image resources and backgrounds"

### Background Processing
- "Use WorkManager for scheduled tasks"
- "Implement proper timeout handling"
- "Respect battery optimization settings"
- "Use appropriate work constraints"

## Security & Privacy

### Data Protection
- "Encrypt sensitive user data"
- "Use DataStore for preferences (not SharedPreferences)"
- "Implement proper data validation"
- "Follow privacy-by-design principles"

### Permissions
- "Request minimal permissions"
- "Handle permission denials gracefully"
- "Use runtime permissions for sensitive features"
- "Document permission usage in manifest"

## Build & Deployment

### Build Environment Selection
choose_build_environment:
  1. "Check developer platform (Apple Silicon vs others)"
  2. "For Apple Silicon Macs: Use host system builds"
  3. "For other platforms: Prefer Docker for consistency"
  4. "For CI/CD: Always use Docker"

### Gradle Configuration
- "Use Kotlin DSL for build scripts"
- "Enable code shrinking for release builds"
- "Configure ProGuard rules appropriately"
- "Use version catalogs for dependency management"

### Release Process
- "Test on multiple device types and API levels"
- "Verify widget functionality on different launchers"
- "Run full lint analysis before release"
- "Update version code and name appropriately"
- "Use Docker for final release builds (non-Apple Silicon)"

## Troubleshooting Guide

### Common Widget Issues
widget_not_loading:
  cause: "RemoteViews compatibility issues"
  solution: "Check for unsupported attributes and views"
  prevention: "Always run lint analysis for RemoteViews"

widget_not_updating:
  cause: "Missing widget notification calls"
  solution: "Ensure repository calls notifyWidgets() on data changes"
  prevention: "Add widget update calls to all data modification methods"

### Build Issues
compilation_errors:
  - "Check Kotlin version compatibility"
  - "Verify all imports are correct"
  - "Ensure proper dependency versions"
  - "For Apple Silicon: Use host builds, not Docker"

lint_failures:
  - "Address RemoteViews compatibility warnings first"
  - "Fix unused resource warnings"
  - "Resolve API level compatibility issues"

### Performance Issues
slow_widget_updates:
  cause: "Heavy operations on main thread"
  solution: "Move operations to background threads"
  prevention: "Use coroutines for all async operations"

memory_leaks:
  cause: "Retained references to Context or Activity"
  solution: "Use Application context where possible"
  prevention: "Review lifecycle-aware components usage"

### Docker-Specific Issues
docker_build_failures:
  - "Check if running on Apple Silicon (use host builds instead)"
  - "Verify Docker Desktop is running and has sufficient resources"
  - "Clear Docker cache: docker system prune -af"
  - "Rebuild images: ./docker-dev.sh rebuild"

docker_performance_issues:
  - "Increase Docker Desktop memory allocation (8GB recommended)"
  - "Use volume caching for faster builds"
  - "Check available disk space (minimum 10GB free)"

## Development Workflow

### Feature Development
1. "Determine build environment (Docker vs host based on platform)"
2. "Create feature branch from main"
3. "Implement feature following architecture patterns"
4. "Add appropriate tests"
5. "Run lint and build verification (use Docker for CI if possible)"
6. "Update documentation if needed"
7. "Create pull request with detailed description"

### Code Review Checklist
- "Follows established architecture patterns"
- "Includes appropriate error handling"
- "Has proper documentation"
- "Passes all tests and lint checks"
- "Maintains widget compatibility"
- "Follows naming conventions"
- "Uses appropriate build environment recommendations"

### Release Preparation
- "Update PRD.md with new features"
- "Verify all widgets work correctly"
- "Test on minimum API level (24)"
- "Run performance testing"
- "Update version information"
- "Use Docker for final release builds (when compatible)"

## AI Assistant Guidelines

### When Adding New Features
1. "Always reference existing similar components"
2. "Follow established patterns and conventions"
3. "Consider widget impact and update requirements"
4. "Implement proper error handling and validation"
5. "Add appropriate logging and monitoring"
6. "Choose appropriate build environment based on target platform"

### When Helping with Build Issues
1. "First ask about developer platform (Mac type, OS)"
2. "Recommend host builds for Apple Silicon users"
3. "Suggest Docker for CI/CD and non-Apple Silicon development"
4. "Reference appropriate documentation (DOCKER_GUIDE.md, etc.)"
5. "Provide platform-specific troubleshooting steps"

### When Debugging Issues
1. "Check lint output for RemoteViews compatibility"
2. "Verify widget registration in AndroidManifest.xml"
3. "Ensure proper thread usage (main vs background)"
4. "Check for memory leaks and performance issues"
5. "Validate data flow from repository to UI"
6. "Consider build environment as potential factor"

### When Refactoring Code
1. "Maintain existing public APIs where possible"
2. "Update all affected widgets and components"
3. "Ensure backward compatibility"
4. "Update tests and documentation"

## Code Optimization & Debugging Guidelines

### Performance Best Practices
critical_performance_rules:
  - "NEVER use runBlocking in UI or widget operations - use caching or suspend functions"
  - "NEVER block UI thread for data loading - use StateFlow and proper coroutines"
  - "Always use applicationContext to prevent memory leaks"
  - "Implement caching for expensive operations (widget customizations, data loading)"
  - "Use memoization in Compose for complex calculations"

widget_performance_rules:
  - "Cache widget customizations with TTL (30 seconds recommended)"
  - "Implement graceful fallbacks for all widget data operations"
  - "Use PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT for Android 12+"
  - "Batch widget updates when possible to reduce system calls"
  - "Handle widget provider exceptions gracefully to prevent crashes"

### Debug Utilities Usage
use_debugutils_instead_of_raw_logging: |
  Always use DebugUtils instead of android.util.Log for consistent logging:
  
  ✅ CORRECT:
  DebugUtils.logWidget("Widget updated successfully")
  DebugUtils.logError("Repository", "Failed to load data", exception)  
  DebugUtils.measureOperation("LoadBookmarks") { /* operation */ }
  DebugUtils.logRepository("Cache invalidated")
  
  ❌ AVOID:
  android.util.Log.d("TAG", "Message")
  Log.e("Error", "Something failed")

debug_feature_flags:
  - "DETAILED_WIDGET_LOGGING: Widget-specific debug information (debug builds only)"
  - "PERFORMANCE_TIMING: Operation timing measurements (debug builds only)"
  - "MEMORY_MONITORING: Basic memory usage tracking (disabled by default)"
  - "CRASH_REPORTING: Exception reporting and logging (always enabled)"
  - "VERBOSE_REPOSITORY_LOGGING: Detailed repository operations (disabled - too verbose)"

conditional_logging_pattern: |
  All debug logging is automatically filtered by build type:
  - Debug builds: Full logging with performance timing
  - Release builds: Only warnings, errors, and crash reporting
  - Production: Minimal logging for better battery life

### Widget Optimization Patterns
widget_caching_implementation:
  pattern: |
    // Implement simple caching to avoid blocking operations
    private val customizationCache = mutableMapOf<WidgetType, WidgetCustomization>()
    private var lastCacheUpdate = 0L
    private const val CACHE_VALIDITY_MS = 30000L // 30 seconds
    
    private fun getCachedCustomization(widgetType: WidgetType): WidgetCustomization {
        val now = System.currentTimeMillis()
        if (now - lastCacheUpdate < CACHE_VALIDITY_MS && customizationCache.containsKey(widgetType)) {
            return customizationCache[widgetType]!!
        }
        
        val defaultCustomization = WidgetCustomization.createDefault(widgetType)
        customizationCache[widgetType] = defaultCustomization
        lastCacheUpdate = now
        return defaultCustomization
    }

error_handling_pattern: |
  Always implement graceful fallbacks in widget operations:
  
  try {
      // Primary operation
      performWidgetUpdate()
  } catch (e: Exception) {
      DebugUtils.logError("Widget", "Primary operation failed: ${e.message}", e)
      // Graceful fallback
      applyDefaultWidgetState()
  }

### Memory Optimization Rules
prevent_memory_leaks:
  - "Use context.applicationContext in repositories and singletons"
  - "Clear unused references in widget operations"
  - "Use weak references for event listeners"
  - "Implement proper cleanup in lifecycle-aware components"

compose_performance:
  - "Add @Stable annotations to data classes used in Compose"
  - "Use remember() for expensive calculations"
  - "Use derivedStateOf for computed properties"
  - "Avoid creating objects in Composable functions"

repository_optimization:
  - "Implement singleton pattern with thread-safe getInstance()"
  - "Use Flow for reactive data with proper distinctUntilChanged()"
  - "Cache frequently accessed data with TTL"
  - "Use mutex for thread-safe operations"

### Code Quality Enforcement
deprecated_api_handling:
  - "Replace all deprecated API usage with modern alternatives"
  - "Use version checks for API compatibility"
  - "Add TODO comments with migration plans for complex deprecated APIs"
  - "Test on minimum API level (24) to ensure compatibility"

exception_handling_strategy:
  - "Use Result<T> pattern for operations that can fail"
  - "Implement specific exception types for different error conditions"
  - "Always log exceptions with proper context"
  - "Provide meaningful error messages for user-facing errors"

### Performance Monitoring Guidelines
operation_timing:
  pattern: |
    // Use DebugUtils for automatic performance timing in debug builds
    DebugUtils.measureOperation("LoadBookmarks") {
        val bookmarks = repository.getBookmarks()
        updateUI(bookmarks)
    }
    
    // Or manual timing for specific measurements
    DebugUtils.startTiming("CustomOperation")
    performComplexOperation()
    DebugUtils.endTiming("CustomOperation") // Logs if > 100ms

memory_monitoring:
  usage: |
    // Only enable in debug builds for troubleshooting
    if (DebugUtils.FeatureFlags.MEMORY_MONITORING) {
        val memoryInfo = DebugUtils.getMemoryInfo()
        DebugUtils.logDebug("Memory", memoryInfo)
    }

### AI Assistant Optimization Guidelines
when_optimizing_code:
1. "Always check for runBlocking usage first - highest priority fix"
2. "Look for direct android.util.Log usage and replace with DebugUtils"
3. "Implement caching for expensive operations, especially in widgets"
4. "Add proper error handling with graceful fallbacks"
5. "Use applicationContext to prevent memory leaks"
6. "Consider performance impact of changes (measure before/after)"

when_debugging_performance_issues:
1. "Use DebugUtils.measureOperation() to identify bottlenecks"
2. "Check for memory leaks with proper context usage"
3. "Verify widget operations are not blocking UI thread"
4. "Look for unnecessary recomputations in Compose"
5. "Ensure proper caching is implemented"

when_adding_logging:
1. "Always use DebugUtils instead of raw Log calls"
2. "Choose appropriate log level (logDebug, logInfo, logWarning, logError)"
3. "Use feature flags for verbose logging"
4. "Include exception details in error logs"
5. "Use consistent tag naming with GLW_ prefix"

optimization_priority_order:
1. "P0: Fix UI blocking operations (runBlocking, heavy operations on main thread)"
2. "P1: Replace complex/over-engineered components with simpler alternatives"
3. "P2: Implement proper caching and memory management"
4. "P3: Add comprehensive debugging utilities"
5. "P4: Clean up deprecated APIs and improve code quality"
5. "Verify performance impact"
6. "Test across different build environments when possible"

### Code Generation Preferences
- "Prefer explicit types over var/val inference when clarity improves"
- "Use meaningful variable and function names"
- "Include comprehensive error handling"
- "Add appropriate logging statements"
- "Follow Material Design 3 principles for UI components"
- "Consider build environment compatibility when suggesting solutions"

## Project-Specific Context

### Widget Types Implemented
1. **GermanLearningWidget**: Main learning widget with sentence delivery
2. **BookmarksWidget**: Standard bookmark browsing widget
3. **BookmarksHeroWidget**: Material Design 3 Hero carousel widget

### Key Data Models
- **GermanSentence**: Core content model with validation and caching
- **UserPreferences**: User settings with DataStore persistence

### Background Processing
- **SentenceDeliveryWorker**: Scheduled sentence updates with timeout protection
- **Widget synchronization**: Cross-widget data synchronization system

### Docker Infrastructure Status
- **Production Ready**: Complete CI/CD pipeline with GitHub Actions
- **Platform Limitation**: Apple Silicon incompatibility with AAPT2
- **Team Ready**: Full documentation and helper scripts available
- **Deployment Ready**: Automated APK building and Play Store integration

### Current State
- "Production-ready codebase with comprehensive optimizations"
- "All widgets tested and RemoteViews compatible"
- "Full MVVM architecture implementation"
- "Material Design 3 compliance"
- "Comprehensive error handling and validation"
- "Docker infrastructure complete with 90% compatibility"

This rules file should be referenced for all development decisions and code generation tasks related to the German Learning Widget project, including appropriate build environment selection based on developer platform and requirements. 